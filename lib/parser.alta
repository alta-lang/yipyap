import String, CodePoint from "string"
import Size, SizeMaximum from "types"
import Stack from "stack"
import List from "list"
import Exception from "exceptions"
import escape, unescape from "util.alta"
import "objects.alta" as YAML
import Vector from "vector"
import parseNumber from "util"
import "chars.alta" as YAMLChars
import Map from "map"
import TagResolver from "tags.alta"
import Box from "memory"
import "schemas.alta" as Schemas

##define YIPYAP_DEBUG true

##if YIPYAP_DEBUG
import printLine from "io"
##end if

export class MisalignedIndentation extends Exception {}
export class InvalidCharacter extends Exception {}
export class ExpectedIndent extends Exception {}
export class UnexpectedExit extends Exception {}
export class InvalidBlockSequenceLocation extends Exception {}
export class UnexpectedToken extends Exception {}
export class UndefinedAlias extends Exception {}
export class UnresolvedHandle extends Exception {}
export class MultipleDocumentStartsFound extends Exception {}
export class PrematureDocumentEndFound extends Exception {}
export class ExpectedDocumentStart extends Exception {}
export class IncompatibleVersion extends Exception {}
export class MultipleVersionDirectivesFound extends Exception {}

enum TokenType: Size {
  Any,
  Indent,
  Outdent,
  Scalar,
  KeyValueSeparator,
  SequenceIndicator,
  MappingStartIndicator,
  MappingEndIndicator,
  SequenceStartIndicator,
  SequenceEndIndicator,
  ItemSeparator,
  ComplexKeyIndicator,
  AnchorName,
  AliasName,
  TagName,
  DocumentStartMarker,
  DocumentEndMarker,
  Directive,
  EOF,
}

class Token {
  public var type = TokenType.Any
  public var value: String
  public var line: Size = 0
  public var column: Size = 0

  public constructor(type: TokenType, line: Size, column: Size) {
    this.type = type
    this.line = line
    this.column = column
  }
  public constructor(value: String, line: Size, column: Size) {
    this.value = value
    this.line = line
    this.column = column
  }
  public constructor(type: TokenType, line: Size, column: Size, value: String) {
    this.type = type
    this.line = line
    this.column = column
    this.value = value
  }

  public to String {
    return this.value
  }

  public this += String: ref Token {
    this.value += $
    return this
  }
}

enum Rule: Size {
  Expression,
  Mapping,
  Sequence,
  Scalar,
  FlowMapping,
  FlowSequence,
}

class Level {
  public var rule: Rule = Rule.Expression
  public var node: YAML.NodeBox = nullptr
  public var cache: Vector<YAML.NodeBox>
  public var iteration: Size = SizeMaximum
  public var state: Size = 0
  public var isRoot = false
  public var rootIndent: Size = 0
  public var currentAddedSpaces: Size = 0
  public var handedOff = false
  public var noBlock = false
  public var needsSeparator = false
  public var checkForEnd = false
  public var gettingKey = false
  public var isComplexKey = false
  public var lineOfLastToken: Size = 0
  public var anchorFor: String = ""
  public var columnOfLastToken: Size = 0
  public var associatedTag: String = ""
  public var columnOfParent: Size? = null

  public constructor() {}
  public constructor(rule: Rule) {
    this.rule = rule
  }
}

function isWhitespace(char: CodePoint): bool {
  return char == ' ' || char == '\t' || char == '\n' || char == '\r'
}

enum ChompingStyle: Size {
  Clip,
  Strip,
  Keep,
}

enum BlockScalarStyle: Size {
  Literal,
  Folding,
}

export class Parser {
  private var input: String
  private var tokens: List<Token>

  public var roots = new Vector<YAML.NodeBox>
  private var root: ptr YAML.NodeBox = nullptr

  private var currentLine: Size = 0
  private var currentColumn: Size = 0

  public var tagResolver = new Box<TagResolver>(new* TagResolver)
  public var schema = Schemas.coreSchemaFactory()

  public function feed(input: String): void {
    this.input += input
    if input[input.length - 1] != '\n'
      this.input += '\n'
  }

  public function finish(): void {
    this.scan()
    this.tokens.pushBack(new Token(TokenType.EOF, this.currentLine, this.currentColumn))
    this.parse()
  }

  private function process(node: ref YAML.NodeBox): void {
    let string = (node as ref YAML.Node) as ref YAML.String

    let trim = () => void {
      let newStr: String
      let start: Size = 0
      let end: Size = string.length
      while start < string.length && isWhitespace(string[start])
        start += 1
      while end > 0 && isWhitespace(string[end - 1])
        end -= 1
      string = string.substring(from: start, to: end)
    }

    if string.length > 1 && string[0] == '"' {
      if string.tag == "?"
        string._tag("tag:yaml.org,2002:str")
      trim()
      let newStr: String
      let firstNewlineFound = false
      let firstInLine = true
      for char: CodePoint in string.items {
        if !firstNewlineFound && char == '\n' {
          let trimIdx = newStr.length
          while trimIdx > 0 && (newStr[trimIdx - 1] == ' ' || newStr[trimIdx - 1] == '\t')
            trimIdx -= 1
          newStr = newStr.substring(to: trimIdx)
          firstNewlineFound = true
          firstInLine = true
        } else if firstNewlineFound && char != '\n' && !(newStr.length == 0 || newStr[newStr.length - 1] == '\n') {
          if newStr[newStr.length - 1] == '\\'
            newStr = newStr.substring(to: newStr.length - 1)
          else
            newStr += ' '
          newStr += char
          firstNewlineFound = false
          firstInLine = false
        } else if firstNewlineFound && char == '\n' {
          newStr += '\n'
          firstInLine = true
        } else {
          firstNewlineFound = false
          newStr += char
          firstInLine = false
        }
      }
      string = unescape(newStr.substring(from: 1, to: newStr.length - 1))
    } else if string.length > 1 && string[0] == '\'' {
      if string.tag == "?"
        string._tag("tag:yaml.org,2002:str")
      trim()
      let newStr: String
      let firstNewlineFound = false
      let firstInLine = true
      for char: CodePoint in string.items {
        if !firstNewlineFound && char == '\n' {
          let trimIdx = newStr.length
          while trimIdx > 0 && (newStr[trimIdx - 1] == ' ' || newStr[trimIdx - 1] == '\t')
            trimIdx -= 1
          newStr = newStr.substring(to: trimIdx)
          firstNewlineFound = true
          firstInLine = true
        } else if firstNewlineFound && char != '\n' && !(newStr.length == 0 || newStr[newStr.length - 1] == '\n') {
          newStr += ' '
          newStr += char
          firstNewlineFound = false
          firstInLine = false
        } else if firstNewlineFound && char == '\n' {
          newStr += '\n'
          firstInLine = true
        } else {
          if char != '\'' || newStr.length == 0 || newStr[newStr.length - 1] != '\'' {
            newStr += char
          }
          firstNewlineFound = false
          firstInLine = false
        }
      }
      string = newStr.substring(from: 1, to: newStr.length - 1)
    } else if string.length > 1 && (string[0] == '|' || string[0] == '>') {
      if string.tag == "?"
        string._tag("tag:yaml.org,2002:str")
      let i: Size = 1
      if string.length > i && (string[i] == '+' || string[i] == '-')
        i += 1
      while string.length > i && string[i] >= '0' && string[i] <= '9'
        i += 1
      while string.length > i && string[i] == ' '
        i += 1
      if string.length <= i || string[i] != '\n'
        return trim()
      let chomping = ChompingStyle.Clip
      let blockStyle = BlockScalarStyle.Literal
      if string[0] == '>'
        blockStyle = BlockScalarStyle.Folding
      if string.length > 1 {
        if string[1] == '+'
          chomping = ChompingStyle.Keep
        else if string[1] == '-'
          chomping = ChompingStyle.Strip
      }
      string = string.substring(from: i + 1)
      if chomping == ChompingStyle.Strip || chomping == ChompingStyle.Clip {
        let finalIndex = string.length
        while finalIndex > 0 && string[finalIndex - 1] == '\n'
          finalIndex -= 1
        string = string.substring(to: finalIndex)
      }
      if chomping == ChompingStyle.Clip
        string += '\n'
      if blockStyle == BlockScalarStyle.Folding {
        let newStr: String
        let firstNewlineFound = false
        let currentLineIndented = false
        let lastLineIndented = false
        let firstInLine = true
        for char: CodePoint in string.items {
          if !firstNewlineFound && char == '\n' {
            if currentLineIndented
              newStr += '\n'
            else
              firstNewlineFound = true
            lastLineIndented = currentLineIndented
            currentLineIndented = false
            firstInLine = true
          } else if firstNewlineFound && (char == ' ' || char == '\t') && firstInLine {
            firstNewlineFound = false
            currentLineIndented = true
            newStr += '\n'
            newStr += char
            firstInLine = false
          } else if firstNewlineFound && char != '\n' && !(newStr.length == 0 || newStr[newStr.length - 1] == '\n') {
            newStr += ' '
            newStr += char
            firstNewlineFound = false
            firstInLine = false
          } else if firstNewlineFound && char == '\n' {
            newStr += '\n'
            lastLineIndented = currentLineIndented
            currentLineIndented = false
            firstInLine = true
          } else {
            firstNewlineFound = false
            newStr += char
            firstInLine = false
          }
        }
        string = newStr
      }
    } else {
      # it's a plain scalar
      trim()
      # if it's an unspecified tag, try to parse it
      if string.tag == "?" {
        for processor: Schemas.Processor in this.schema.items {
          if let processed = processor(string) {
            node = *processed
            ;(node as ref YAML.Node).tagResolver = this.tagResolver
            break
          }
        }
        if (node as ref YAML.Node).tag == "?" {
          (node as ref YAML.Node)._tag("tag:yaml.org,2002:str")
        }
      }
    }
  }

  private function resolveTag(tag: String): String {
    let tagger = this.tagResolver as ref TagResolver
    let markIdx = tag.indexOf('!')
    if markIdx != SizeMaximum {
      let handle = tag.substring(0, to: markIdx)
      let rest = tag.substring(markIdx + 1)
      # handle `!<whatever>`
      if rest.length > 1 && rest[0] == '<' && rest[rest.length - 1] == '>'
        return rest.substring(from: 1, to: rest.length - 1)
      # handle `!my-handle!my-thing
      if handle {
        if !tagger.namespaces.has(handle)
          throw new UnresolvedHandle
        return tagger.namespaces[handle] + rest
      } else {
        # handle `!!my-thing`
        return tagger.secondaryNamespace + rest
      }
    } else if tagger.primaryNamespace != "!" {
      # handle non-default primary namespaces
      return tagger.primaryNamespace + tag
    }
    return tag
  }

  public function scan(): void {
    let handlingIndent = false
    let indents: Stack<Size>
    let spacesFound: Size = 0
    let unprocessed = new Token("", 0, 0)
    let lastTok: Token? = null
    let lastChar: CodePoint = '\0'

    let checkingForArray = false
    let checkingForSeparator = false
    let ignoringWhitespace = false
    let inDoubleQuotedString = false
    let inSingleQuotedString = false
    let acceptNext = false
    let mightExitSingleQuotedString = false
    let checkIndents = true
    let inComment = false
    let lastCharacterWasSpace = false
    let inBlockScalar = false
    let startingBlockScalar = false
    let blockScalarInitialIndent: Size = 0
    let flowCollectionCount: Size = 0
    let ignoringWhitespaceColumns = false
    let goToNextCharacter = true
    let inAnchorOrAliasName = false
    let inTagName = false
    let inTagHandle = false
    let inDirective = false
    let checkingForDocumentEnd = false
    let checkingForDocumentStart = false

    let pushToken = (token: Token) => void {
      this.tokens.pushBack(token)
      lastTok = token
    }

    let pushUnprocessed = () => bool {
      let pushIt = unprocessed.value.length != 0 || inBlockScalar
      if pushIt
        pushToken(unprocessed)
      unprocessed = new Token("", this.currentLine, this.currentColumn)
      return pushIt
    }

    let iter = this.input.items
    let maybeChar = iter.next()

    while maybeChar {
      let char = *maybeChar
      let processIndent = false

      if lastChar == '\n' && char == '\n' && !inDoubleQuotedString && !inSingleQuotedString {
        pushUnprocessed()
        unprocessed.line = this.currentLine + 1
        unprocessed.column = 0
      }

      if this.currentColumn == 0 && checkIndents {
        handlingIndent = true
        if char == ' '
          spacesFound = 1
        else if char == '\n'
          spacesFound = 0
        else
          processIndent = true
      } else if handlingIndent {
        if char == ' '
          spacesFound += 1
        else if char == '\n'
          spacesFound = 0
        else
          processIndent = true
      }

      if processIndent {
        handlingIndent = false
        unprocessed.column += spacesFound
        if indents.length == 0 || spacesFound > indents.top {
          indents.push(spacesFound)
          let str: String
          for i: Size in 0..indents.top {
            str += ' '
          }
          pushToken(new Token(TokenType.Indent, this.currentLine, this.currentColumn - spacesFound, str))
        } else {
          while indents.length > 1 && spacesFound < indents.top {
            indents.pop()
            let str: String
            for i: Size in 0..indents.top {
              str += ' '
            }
            pushToken(new Token(TokenType.Outdent, this.currentLine, this.currentColumn, str))
          }
          if spacesFound > indents.top
            throw new MisalignedIndentation
        }
        spacesFound = 0
      }

      if handlingIndent && !processIndent {
        # do nothing
      } else if ignoringWhitespace && char == ' ' {
        if !ignoringWhitespaceColumns
          unprocessed.column = this.currentColumn + 1
      } else {
        ignoringWhitespace = false
        ignoringWhitespaceColumns = false
        if mightExitSingleQuotedString {
          if char != '\'' {
            checkIndents = true
            inSingleQuotedString = false
            mightExitSingleQuotedString = false
            pushUnprocessed()
          }
        }
        if inComment {
          if char == '\n'
            inComment = false
        } else if inDirective {
          if char == '\n' {
            pushUnprocessed()
            inDirective = false
          } else {
            unprocessed += char
          }
        }
        if inBlockScalar {
          if startingBlockScalar {
            if !((unprocessed.value.length == 1 && (char == '+' || char == '-')) || (char >= '0' && char <= '9')) {
              startingBlockScalar = false
              let explicitStr = unprocessed.value.substring(from: (unprocessed.value.length > 1 && (unprocessed.value[1] == '+' || unprocessed.value[1] == '-')) ? 2 : 1)
              if explicitStr {
                let explicitIndent = parseNumber<Size>(explicitStr)
                indents.push(indents.top + explicitIndent)
                let str: String
                for i: Size in 0..indents.top {
                  str += ' '
                }
                pushToken(new Token(TokenType.Indent, this.currentLine + 1, 0, str))
              }
            }
          } else if indents.top <= blockScalarInitialIndent {
            inBlockScalar = false
          }
        }
        let flowBoundary = (!lastTok || ((*lastTok).type != TokenType.Any) || (*lastTok).line != this.currentLine) && flowCollectionCount > 0
        let atBoundary = (!lastTok || ((*lastTok).type != TokenType.Any) || (*lastTok).line != this.currentLine) && unprocessed.value.length == 0
        if inComment || inDirective {
          # do nothing
        } else if inDoubleQuotedString {
          unprocessed += char
          if char == '\n' {
            ignoringWhitespace = true
            ignoringWhitespaceColumns = true
          }
          if acceptNext {
            acceptNext = false
          } else if char == '"' {
            inDoubleQuotedString = false
            checkIndents = true
            pushUnprocessed()
          } else if char == '\\' {
            acceptNext = true
          }
        } else if inSingleQuotedString {
          unprocessed += char
          if mightExitSingleQuotedString
            mightExitSingleQuotedString = false
          else if char == '\''
            mightExitSingleQuotedString = true
          else if char == '\n'
            ignoringWhitespace = true
        } else if inAnchorOrAliasName {
          if !YAMLChars.isAnchorCharacter(char) {
            goToNextCharacter = false
            inAnchorOrAliasName = false
            pushUnprocessed()
            ignoringWhitespace = true
          } else {
            unprocessed += char
          }
        } else if inTagName {
          if YAMLChars.isWhitespace(char) {
            pushUnprocessed()
            inTagName = false
            goToNextCharacter = false
            ignoringWhitespace = true
          } else {
            unprocessed += char
          }
        } else if checkingForArray {
          checkingForArray = false
          if char == ' ' || char == '\n' {
            unprocessed.value = unprocessed.value.substring(length: unprocessed.value.length - 1)
            pushUnprocessed()
            unprocessed.column = this.currentColumn + 1
            if (!lastTok || (*lastTok).type != TokenType.Indent) && (indents.top == 0 || indents.top != this.currentColumn - 1) {
              if this.currentColumn != 0
                indents.push(this.currentColumn - 1)
              let str: String
              for i: Size in 0..indents.top {
                str += ' '
              }
              pushToken(new Token(TokenType.Indent, this.currentLine, this.currentColumn - 1, str))
            }
            pushToken(new Token(TokenType.SequenceIndicator, this.currentLine, this.currentColumn - 1))
            ignoringWhitespace = true
          } else if this.currentColumn == 1 && char == '-' {
            checkingForDocumentStart = true
            unprocessed += char
          } else {
            unprocessed += char
          }
        } else if checkingForSeparator {
          checkingForSeparator = false
          let lastChar = unprocessed.value.length > 1 ? unprocessed.value[unprocessed.value.length - 2] : ((!lastTok || (*lastTok).value.length == 0) ? '\0' as CodePoint : (*lastTok).value[(*lastTok).value.length - 1])
          if (flowCollectionCount > 0 && (lastChar == '"' || char == '"' || char == '[' || char == '{')) || char == ' ' || char == '\n' {
            unprocessed.value = unprocessed.value.substring(length: unprocessed.value.length - 1)
            if indents.length == 0 || (unprocessed.column > indents.top && unprocessed.value.length > 0) {
              indents.push(unprocessed.column)
              let str: String
              for i: Size in 0..indents.top {
                str += ' '
              }
              pushToken(new Token(TokenType.Indent, this.currentLine, unprocessed.column, str))
            }
            pushUnprocessed()
            if char == '\n'
              unprocessed = new Token("", this.currentLine + 1, 0)
            else if char == ' '
              unprocessed.column = this.currentColumn + 1
            else
              goToNextCharacter = false
            pushToken(new Token(TokenType.KeyValueSeparator, this.currentLine, this.currentColumn - 1))
            ignoringWhitespace = true
          } else {
            unprocessed += char
          }
        } else if checkingForDocumentStart {
          checkingForDocumentStart = false
          unprocessed += char
          if char == '-' {
            checkIndents = true
            unprocessed.type = TokenType.DocumentStartMarker
            pushUnprocessed()
            while indents.length > 0
              indents.pop()
          }
        } else if checkingForDocumentEnd {
          checkingForDocumentEnd = false
          unprocessed += char
          if this.currentColumn == 1 {
            if char == '.'
              checkingForDocumentEnd = true
          } else {
            if char == '.' {
              checkIndents = false
              unprocessed.type = TokenType.DocumentEndMarker
              pushUnprocessed()
              while indents.length > 0
                indents.pop()
            }
          }
        } else if char == '\n' {
          pushUnprocessed()
          unprocessed.line = this.currentLine + 1
          unprocessed.column = 0
        } else if char == '#' && (this.currentColumn == 0 || lastCharacterWasSpace) && !inBlockScalar {
          inComment = true
          pushUnprocessed()
        } else if char == ':' && !inBlockScalar {
          checkingForSeparator = true
          unprocessed += char
        } else if atBoundary && char == '-' {
          checkingForArray = true
          unprocessed += char
        } else if atBoundary && char == '"' && !inBlockScalar {
          inDoubleQuotedString = true
          checkIndents = false
          pushUnprocessed()
          unprocessed += char
          unprocessed.type = TokenType.Scalar
        } else if atBoundary && char == '\'' && !inBlockScalar {
          inSingleQuotedString = true
          checkIndents = false
          pushUnprocessed()
          unprocessed += char
          unprocessed.type = TokenType.Scalar
        } else if atBoundary && char == '{' && !inBlockScalar {
          flowCollectionCount += 1
          pushUnprocessed()
          pushToken(new Token(TokenType.MappingStartIndicator, this.currentLine, this.currentColumn))
        } else if flowBoundary && char == '}' && !inBlockScalar {
          flowCollectionCount -= 1
          pushUnprocessed()
          pushToken(new Token(TokenType.MappingEndIndicator, this.currentLine, this.currentColumn))
        } else if atBoundary && char == '[' && !inBlockScalar {
          flowCollectionCount += 1
          pushUnprocessed()
          pushToken(new Token(TokenType.SequenceStartIndicator, this.currentLine, this.currentColumn))
        } else if flowBoundary && char == ']' && !inBlockScalar {
          flowCollectionCount -= 1
          pushUnprocessed()
          pushToken(new Token(TokenType.SequenceEndIndicator, this.currentLine, this.currentColumn))
        } else if flowCollectionCount > 0 && char == ',' {
          pushUnprocessed()
          pushToken(new Token(TokenType.ItemSeparator, this.currentLine, this.currentColumn))
        } else if atBoundary && char == '?' && !inBlockScalar {
          pushUnprocessed()
          pushToken(new Token(TokenType.ComplexKeyIndicator, this.currentLine, this.currentColumn))
          ignoringWhitespace = true
        } else if atBoundary && (char == '>' || char == '|') {
          pushUnprocessed()
          inBlockScalar = true
          startingBlockScalar = true
          blockScalarInitialIndent = indents.top
          unprocessed += char
        } else if (
          atBoundary &&
          (
            !lastTok ||
            (*lastTok).type == TokenType.KeyValueSeparator ||
            (*lastTok).type == TokenType.TagName ||
            (*lastTok).type == TokenType.ItemSeparator ||
            (*lastTok).type == TokenType.SequenceStartIndicator ||
            (*lastTok).type == TokenType.ComplexKeyIndicator
          ) &&
          (
            char == '&' ||
            char == '*'
          )
        ) {
          pushUnprocessed()
          inAnchorOrAliasName = true
          unprocessed.type = (char == '&') ? TokenType.AnchorName : TokenType.AliasName
        } else if (
          atBoundary &&
          (
            !lastTok ||
            (*lastTok).type == TokenType.KeyValueSeparator ||
            (*lastTok).type == TokenType.AnchorName ||
            (*lastTok).type == TokenType.ItemSeparator ||
            (*lastTok).type == TokenType.SequenceStartIndicator ||
            (*lastTok).type == TokenType.ComplexKeyIndicator
          ) &&
          char == '!'
        ) {
          pushUnprocessed()
          inTagName = true
          inTagHandle = true
          unprocessed.type = TokenType.TagName
        } else if this.currentColumn == 0 && char == '%' {
          pushUnprocessed()
          inDirective = true
          unprocessed.type = TokenType.Directive
        } else if this.currentColumn == 0 && char == '.' {
          pushUnprocessed()
          checkingForDocumentEnd = true
        } else {
          unprocessed += char
        }
      }

      lastCharacterWasSpace = char == ' '

      if char == '\n' {
        this.currentLine += 1
        this.currentColumn = 0
      } else {
        this.currentColumn += 1
      }
      lastChar = char
      if goToNextCharacter
        maybeChar = iter.next()
      else
        goToNextCharacter = true
    }
  }

  public function parse(): void {
    let levels: Stack<Level>

    levels.push(new Level(Rule.Expression))

    levels.top.isRoot = true
    levels.top.state = 2

    let it = this.tokens.items
    let lastNode: YAML.NodeBox = nullptr
    let tok = it.next()
    let anchors = new Map<String, YAML.NodeBox>
    let foundDirectives = false
    let foundStartMarker = false
    let startingDocument = true
    let foundVersion = false

    let handleHandedOff = (level: ref Level) => void {
      let tmp: String
      if !lastNode {
        lastNode = new* YAML.String("")
        ;(lastNode as ref YAML.Node)._tag("?")
      }
      tmp = (lastNode as ref YAML.Node).toString()
      if (lastNode as ref YAML.Node) instanceof YAML.String
        this.process(lastNode)
      if level.rule == Rule.Mapping || level.rule == Rule.FlowMapping {
        if level.gettingKey {
          level.gettingKey = false
          level.cache.push(lastNode)
        } else {
          let key: YAML.NodeBox = nullptr
          if level.cache.length > 0 {
            key = level.cache.pop()
          } else {
            key = new* YAML.String("")
            ;(key as ref YAML.Node)._tag("?")
            this.process(key)
          }
          ;(level.node as ref YAML.Mapping)[key] = lastNode
        }
      } else if level.rule == Rule.Sequence || level.rule == Rule.FlowSequence {
        (level.node as ref YAML.Sequence).push(lastNode)
      }
      lastNode = nullptr
      if level.rule == Rule.FlowMapping || level.rule == Rule.FlowSequence
        level.needsSeparator = true
    }

    while tok {
      let token = *tok

      ##if YIPYAP_DEBUG
        if token.type == TokenType.Indent
          printLine("indent token of ", token.value.length, " spaces found at ", token.line + 1, ':', token.column + 1)
        else if token.type == TokenType.Outdent
          printLine("outdent token of ", token.value.length, " spaces found at ", token.line + 1, ':', token.column + 1)
        else if token.type == TokenType.SequenceIndicator
          printLine("sequence indicator found at ", token.line + 1, ':', token.column + 1)
        else if token.type == TokenType.KeyValueSeparator
          printLine("key value separator found at ", token.line + 1, ':', token.column + 1)
        else if token.type == TokenType.Scalar
          printLine("scalar token found at ", token.line + 1, ':', token.column + 1, " with content: \"", escape(token.value), '"')
        else if token.type == TokenType.MappingStartIndicator
          printLine("mapping start indicator found at ", token.line + 1, ':', token.column + 1)
        else if token.type == TokenType.MappingEndIndicator
          printLine("mapping end indicator found at ", token.line + 1, ':', token.column + 1)
        else if token.type == TokenType.SequenceStartIndicator
          printLine("sequence start indicator found at ", token.line + 1, ':', token.column + 1)
        else if token.type == TokenType.SequenceEndIndicator
          printLine("sequence end indicator found at ", token.line + 1, ':', token.column + 1)
        else if token.type == TokenType.ItemSeparator
          printLine("item separator found at ", token.line + 1, ':', token.column + 1)
        else if token.type == TokenType.EOF
          printLine("EOF found")
        else if token.type == TokenType.ComplexKeyIndicator
          printLine("complex key indicator found at ", token.line + 1, ':', token.column + 1)
        else if token.type == TokenType.AnchorName
          printLine("anchor name (\"", escape(token.value), "\") found at ", token.line + 1, ':', token.column + 1)
        else if token.type == TokenType.AliasName
          printLine("alias name (\"", escape(token.value), "\") found at ", token.line + 1, ':', token.column + 1)
        else if token.type == TokenType.TagName
          printLine("tag name (\"", escape(token.value), "\") found at ", token.line + 1, ':', token.column + 1)
        else if token.type == TokenType.Directive
          printLine("directive (\"", escape(token.value), "\") found at ", token.line + 1, ':', token.column + 1)
        else if token.type == TokenType.DocumentStartMarker
          printLine("document start marker found at ", token.line + 1, ':', token.column + 1)
        else if token.type == TokenType.DocumentEndMarker
          printLine("document end marker found at ", token.line + 1, ':', token.column + 1)
        else
          printLine("token found at ", token.line + 1, ':', token.column + 1, " with content: \"", escape(token.value), '"')
      ##end if

      let popAll = () => void {
        while levels.length > 0 {
          let level = levels.top
          if level.handedOff
            handleHandedOff(level)
          if level.rule == Rule.Scalar {
            let str = level.node as ref YAML.String
            for i: Size in level.lineOfLastToken..token.line {
              str += '\n'
            }
          }
          lastNode = level.node
          levels.pop()
        }
      }

      if levels.length == 0 {
        if token.type != TokenType.EOF && token.type != TokenType.Directive && token.type != TokenType.DocumentStartMarker {
          if foundDirectives && !foundStartMarker
            throw new ExpectedDocumentStart
          throw new UnexpectedExit
        } else if token.type == TokenType.EOF {
          break
        }
      }

      let levelCount = levels.length

      let goToNextToken = true
      let continuePass = true

      if token.type == TokenType.Directive {
        continuePass = false
        foundDirectives = true
        foundStartMarker = false
        startingDocument = false
        popAll()
        # process the directive
        if token.value.length > 0 {
          let firstSpace = token.value.indexOf(' ')
          let command = token.value.substring(from: 0, to: firstSpace)
          let args = new Vector<String>
          let argString = token.value.substring(from: firstSpace + 1)
          let i: Size = 0
          while i < argString.length {
            while i < argString.length && argString[i] == ' '
              i += 1
            if i == argString.length
              break
            args.push("")
            while i < argString.length && argString[i] != ' ' {
              args.last += argString[i]
              i += 1
            }
          }
          if command == "YAML" {
            if foundVersion
              throw new MultipleVersionDirectivesFound
            else
              foundVersion = true
            if args.length >= 1 {
              let versionString = args[0]
              let ok = true
              let firstDot = SizeMaximum
              if ok && versionString.length < 3
                ok = false
              if ok && versionString.includes((char: CodePoint) => bool { return !(char >= '0' && char <= '9') && char != '.' })
                ok = false
              if ok && versionString[0] == '.'
                ok = false
              if ok && (firstDot = versionString.indexOf('.')) == SizeMaximum
                ok = false
              if ok && versionString.indexOf('.', after: firstDot) != SizeMaximum
                ok = false
              if ok {
                let major = versionString.substring(from: 0, to: firstDot)
                let minor = versionString.substring(from: firstDot + 1)
                if major != "1"
                  throw new IncompatibleVersion
                # for now, just ignore minor version
              }
            }
          } else if command == "TAG" {
            if args.length >= 2 {
              let tag = args[0]
              let ok = true
              if ok && tag.length < 1
                ok = false
              if ok && tag[0] != '!'
                ok = false
              if ok && tag[tag.length - 1] != '!'
                ok = false
              if ok {
                let tagger = this.tagResolver as ref TagResolver
                # TODO: right now, we use the same TagResolver instance
                #       for all documents, meaning that tag handles set in one
                #       leak into others. fix that.
                if tag == "!"
                  tagger.primaryNamespace = args[1]
                else if tag == "!!"
                  tagger.secondaryNamespace = args[1]
                else
                  tagger.namespaces[tag.substring(from: 1, to: tag.length - 1)] = args[1]
              }
            }
          }
        }
      } else if token.type == TokenType.DocumentStartMarker {
        continuePass = false
        if foundStartMarker
          throw new MultipleDocumentStartsFound
        foundStartMarker = true
        foundDirectives = false
        foundVersion = false
        startingDocument = true
        this.roots.push(new* YAML.Null)
        this.root = &this.roots.last
        levels.push(new Level(Rule.Expression))
        levels.top.isRoot = true
        levels.top.state = 2
      } else if token.type == TokenType.DocumentEndMarker {
        continuePass = false
        if !foundStartMarker
          throw new PrematureDocumentEndFound
        foundStartMarker = false
        startingDocument = false
        popAll()
      }

      if !continuePass {
        tok = it.next()
        continue
      }

      let level: ref Level = levels.top
      level.iteration += 1

      if level.state == 0 {
        if token.type == TokenType.Indent {
          level.rootIndent = token.value.length
          level.state = 2
        } else {
          level.rootIndent = 0
          level.state = 1
          goToNextToken = false
        }
      } else {
        if level.handedOff {
          level.handedOff = false
          handleHandedOff(level)
        }
        if token.type == TokenType.ItemSeparator && level.rule != Rule.FlowMapping && level.rule != Rule.FlowSequence {
          lastNode = level.node
          levels.pop()
          goToNextToken = false
        } else if token.type == TokenType.Outdent {
          if level.rule != Rule.FlowMapping && level.rule != Rule.FlowSequence {
            if level.state == 1 || token.value.length < level.rootIndent {
              if level.rule == Rule.Scalar {
                let str = level.node as ref YAML.String
                for i: Size in level.lineOfLastToken..token.line {
                  str += '\n'
                }
              }
              lastNode = level.node
              levels.pop()
              goToNextToken = false
            } else {
              level.currentAddedSpaces = token.value.length
            }
          }
        } else if token.type == TokenType.Indent {
          if level.state == 1 {
            level.rootIndent = token.value.length
            level.state = 2
          }
          if level.rule != Rule.FlowMapping && level.rule != Rule.FlowSequence
            level.currentAddedSpaces = token.value.length
        } else if level.needsSeparator {
          if token.type == TokenType.ItemSeparator {
            level.needsSeparator = false
            if level.rule == Rule.FlowSequence
              level.checkForEnd = true
          } else if (
            (token.type == TokenType.MappingEndIndicator && level.rule == Rule.FlowMapping) ||
            (token.type == TokenType.SequenceEndIndicator && level.rule == Rule.FlowSequence)
          ) {
            lastNode = level.node
            levels.pop()
          } else {
            throw new UnexpectedToken
          }
        } else if (token.type == TokenType.MappingEndIndicator || token.type == TokenType.SequenceEndIndicator) {
          lastNode = level.node
          levels.pop()
          goToNextToken = (token.type == TokenType.MappingEndIndicator  && level.rule == Rule.FlowMapping ) ||
                          (token.type == TokenType.SequenceEndIndicator && level.rule == Rule.FlowSequence)
        } else if level.checkForEnd {
          level.checkForEnd = false
          level.handedOff = true
          levels.push(new Level(Rule.Expression))
          goToNextToken = false
        } else if token.type == TokenType.Scalar || token.type == TokenType.Any {
          if (
            level.columnOfParent &&
            token.column <= *level.columnOfParent &&
            level.rule != Rule.FlowMapping &&
            level.rule != Rule.FlowSequence &&
            level.state == 1
          ) {
            lastNode = level.node
            levels.pop()
            goToNextToken = false
          } else if level.rule == Rule.Mapping || level.rule == Rule.FlowMapping {
            let str = new* YAML.String(token)
            str._tag("?")
            str.tagResolver = this.tagResolver
            level.cache.push(str)
            this.process(level.cache.last)
          } else {
            let first = false
            if level.node {
              if level.currentAddedSpaces == 0 && token.column < level.columnOfLastToken {
                lastNode = level.node
                levels.pop()
                goToNextToken = false
              }
            } else {
              first = true
              level.rule = Rule.Scalar
              level.node = new* YAML.String
              ;(level.node as ref YAML.Node)._tag("?")
              ;(level.node as ref YAML.Node).tagResolver = this.tagResolver
              if level.associatedTag {
                (level.node as ref YAML.Node)._tag(level.associatedTag)
              }
              if level.anchorFor
                anchors[level.anchorFor] = level.node
            }
            if goToNextToken {
              let str = level.node as ref YAML.String
              if !first {
                for i: Size in level.lineOfLastToken..token.line {
                  str += '\n'
                }
              }
              if level.currentAddedSpaces > level.rootIndent {
                for i: Size in 0..(level.currentAddedSpaces - level.rootIndent) {
                  str += ' '
                }
              }
              str += token.value
              level.lineOfLastToken = token.line
              level.columnOfLastToken = token.column
            }
          }
        } else if token.type == TokenType.KeyValueSeparator {
          if level.rule != Rule.Mapping && level.rule != Rule.FlowMapping {
            if level.isComplexKey {
              lastNode = level.node
              levels.pop()
              goToNextToken = false
            } else {
              let reassignRoot = !this.root || *this.root == level.node
              if level.node {
                level.cache.push(level.node as ref YAML.String)
                this.process(level.cache.last)
              }
              level.node = new* YAML.Mapping
              ;(level.node as ref YAML.Node).tagResolver = this.tagResolver
              if level.associatedTag {
                (level.node as ref YAML.Node)._tag(level.associatedTag)
              }
              if level.anchorFor
                anchors[level.anchorFor] = level.node
              if reassignRoot {
                if this.root {
                  *this.root = level.node
                } else {
                  this.roots.push(level.node)
                  this.root = &this.roots.last
                }
              }
              level.rule = Rule.Mapping
            }
          }
          if goToNextToken {
            level.handedOff = true
            let indent = level.rootIndent
            let noBlock = level.rule == Rule.FlowMapping
            levels.push(new Level(Rule.Expression))
            levels.top.columnOfParent = indent
            levels.top.noBlock = noBlock
          }
        } else if token.type == TokenType.SequenceIndicator {
          if level.noBlock {
            throw new InvalidBlockSequenceLocation
          }
          if level.rule == Rule.Expression {
            let reassignRoot = !this.root || *this.root == level.node
            level.node = new* YAML.Sequence
            ;(level.node as ref YAML.Node).tagResolver = this.tagResolver
            if level.associatedTag {
              (level.node as ref YAML.Node)._tag(level.associatedTag)
            }
            if level.anchorFor
              anchors[level.anchorFor] = level.node
            if reassignRoot {
              if this.root {
                *this.root = level.node
              } else {
                this.roots.push(level.node)
                this.root = &this.roots.last
              }
            }
            level.rule = Rule.Sequence
          } else if level.rule != Rule.Sequence {
            goToNextToken = false
            lastNode = level.node
            levels.pop()
          }
          if goToNextToken {
            level.handedOff = true
            levels.push(new Level(Rule.Expression))
          }
        } else if token.type == TokenType.EOF {
          if levels.length != 1
            goToNextToken = false
          if level.rule == Rule.Scalar {
            let str = level.node as ref YAML.String
            for i: Size in level.lineOfLastToken..token.line {
              str += '\n'
            }
          }
          lastNode = level.node
          levels.pop()
        } else if token.type == TokenType.MappingStartIndicator {
          level.rule = Rule.FlowMapping
          level.node = new* YAML.Mapping
          ;(level.node as ref YAML.Node).tagResolver = this.tagResolver
          if level.associatedTag {
            (level.node as ref YAML.Node)._tag(level.associatedTag)
          }
          if level.anchorFor
            anchors[level.anchorFor] = level.node
        } else if token.type == TokenType.SequenceStartIndicator {
          level.rule = Rule.FlowSequence
          level.node = new* YAML.Sequence
          ;(level.node as ref YAML.Node).tagResolver = this.tagResolver
          level.checkForEnd = true
          if level.associatedTag {
            (level.node as ref YAML.Node)._tag(level.associatedTag)
          }
          if level.anchorFor
            anchors[level.anchorFor] = level.node
        } else if token.type == TokenType.ComplexKeyIndicator {
          if level.rule == Rule.Expression {
            let reassignRoot = !this.root || *this.root == level.node
            level.node = new* YAML.Mapping
            ;(level.node as ref YAML.Node).tagResolver = this.tagResolver
            if level.associatedTag {
              (level.node as ref YAML.Node)._tag(level.associatedTag)
            }
            if level.anchorFor
              anchors[level.anchorFor] = level.node
            if reassignRoot {
              if this.root {
                *this.root = level.node
              } else {
                this.roots.push(level.node)
                this.root = &this.roots.last
              }
            }
            level.rule = Rule.Mapping
          } else if level.rule != Rule.Mapping && level.rule != Rule.FlowMapping {
            lastNode = level.node
            levels.pop()
            goToNextToken = false
          }
          if goToNextToken {
            level.handedOff = true
            level.gettingKey = true
            levels.push(new Level(Rule.Expression))
            levels.top.isComplexKey = true
          }
        } else if token.type == TokenType.AnchorName {
          if level.node
            throw new UnexpectedToken
          level.anchorFor = token.value
        } else if token.type == TokenType.AliasName {
          if level.node
            throw new UnexpectedToken
          if !anchors.has(token.value)
            throw new UndefinedAlias
          level.node = new* YAML.Alias(anchors[token.value])
          ;(level.node as ref YAML.Node).tagResolver = this.tagResolver
          lastNode = level.node
          levels.pop()
        } else if token.type == TokenType.TagName {
          if level.node
            throw new UnexpectedToken
          level.associatedTag = this.resolveTag(token.value)
        }
      }

      if goToNextToken
        tok = it.next()

      if (
        levelCount == levels.length &&
        this.root &&
        (
          !*this.root ||
          (*this.root as ref YAML.Node) instanceof YAML.Null
        ) &&
        level.node
      ) {
        *this.root = level.node
      }
    }

    if this.root && *this.root && (*this.root as ref YAML.Node) instanceof YAML.String
      this.process(*this.root)
  }
}
