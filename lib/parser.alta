import String, CodePoint from "string"
import Size, SizeMaximum from "types"
import printLine from "io"
import Stack from "stack"
import List from "list"
import Exception from "exceptions"
import escape, unescape from "util.alta"
import "objects.alta" as YAML
import Vector from "vector"

export class MisalignedIndentation extends Exception {}
export class InvalidCharacter extends Exception {}
export class ExpectedIndent extends Exception {}
export class UnexpectedExit extends Exception {}
export class InvalidBlockSequenceLocation extends Exception {}
export class UnexpectedToken extends Exception {}

enum TokenType: Size {
  Any,
  Indent,
  Outdent,
  Scalar,
  KeyValueSeparator,
  SequenceIndicator,
  MappingStartIndicator,
  MappingEndIndicator,
  SequenceStartIndicator,
  SequenceEndIndicator,
  ItemSeparator,
  ComplexKeyIndicator,
  EOF,
}

class Token {
  public var type = TokenType.Any
  public var value: String
  public var line: Size = 0
  public var column: Size = 0

  public constructor(type: TokenType, line: Size, column: Size) {
    this.type = type
    this.line = line
    this.column = column
  }
  public constructor(value: String, line: Size, column: Size) {
    this.value = value
    this.line = line
    this.column = column
  }
  public constructor(type: TokenType, line: Size, column: Size, value: String) {
    this.type = type
    this.line = line
    this.column = column
    this.value = value
  }

  public to String {
    return this.value
  }

  public this += String: ref Token {
    this.value += $
    return this
  }
}

enum Rule: Size {
  Expression,
  Mapping,
  Sequence,
  Scalar,
  FlowMapping,
  FlowSequence,
}

class Level {
  public var rule: Rule = Rule.Expression
  public var node: YAML.NodeBox = nullptr
  public var cache: Vector<YAML.NodeBox>
  public var iteration: Size = SizeMaximum
  public var state: Size = 0
  public var isRoot = false
  public var rootIndent: Size = 0
  public var currentAddedSpaces: Size = 0
  public var handedOff = false
  public var noBlock = false
  public var needsSeparator = false
  public var checkForEnd = false
  public var gettingKey = false
  public var isComplexKey = false

  public constructor() {}
  public constructor(rule: Rule) {
    this.rule = rule
  }
}

export class Parser {
  private var input: String
  private var tokens: List<Token>

  public var root: YAML.NodeBox = nullptr

  public var currentLine: Size = 0
  public var currentColumn: Size = 0

  public function feed(input: String): void {
    this.input += input
    if input[input.length - 1] != '\n'
      this.input += '\n'
  }

  public function finish(): void {
    this.scan()
    this.tokens.pushBack(new Token(TokenType.EOF, this.currentLine, this.currentColumn))
    this.parse()
  }

  public function scan(): void {
    let handlingIndent = false
    let indents: Stack<Size>
    let currentLine: Size = 0
    let currentColumn: Size = 0
    let spacesFound: Size = 0
    let unprocessed = new Token("", 0, 0)
    let lastTok: Token? = null

    let checkingForArray = false
    let checkingForSeparator = false
    let ignoringWhitespace = false
    let inDoubleQuotedString = false
    let inSingleQuotedString = false
    let acceptNext = false
    let mightExitSingleQuotedString = false
    let checkIndents = true

    let pushToken = (token: Token) => void {
      this.tokens.pushBack(token)
      lastTok = token
    }

    let pushUnprocessed = () => bool {
      let pushIt = unprocessed.value.length != 0
      if pushIt
        pushToken(unprocessed)
      unprocessed = new Token("", currentLine, currentColumn)
      return pushIt
    }

    for char: CodePoint in this.input.items {
      let processIndent = false

      if currentColumn == 0 && checkIndents {
        handlingIndent = true
        if char == ' '
          spacesFound = 1
        else if char == '\n'
          spacesFound = 0
        else
          processIndent = true
      } else if handlingIndent {
        if char == ' '
          spacesFound += 1
        else if char == '\n'
          spacesFound = 0
        else
          processIndent = true
      }

      if processIndent {
        handlingIndent = false
        unprocessed.column += spacesFound
        if indents.length == 0 || spacesFound > indents.top {
          indents.push(spacesFound)
          let str: String
          for i: Size in 0..indents.top {
            str += ' '
          }
          pushToken(new Token(TokenType.Indent, currentLine, currentColumn - spacesFound, str))
        } else {
          printLine("starting outdent loop; indents.top = ", indents.top, "; spacesFound = ", spacesFound, "; location = ", currentLine + 1, ':', currentColumn + 1)
          while indents.length > 1 && spacesFound < indents.top {
            printLine("popping indent with ", indents.top, " spaces")
            indents.pop()
            let str: String
            for i: Size in 0..indents.top {
              str += ' '
            }
            pushToken(new Token(TokenType.Outdent, currentLine, currentColumn, str))
          }
          printLine("finished outdent loop with indents.top = ", indents.top, " and spacesFound = ", spacesFound)
          if spacesFound > indents.top
            throw new MisalignedIndentation
        }
        spacesFound = 0
      }

      if handlingIndent && !processIndent {
        # do nothing
      } else if ignoringWhitespace && char == ' ' {
        unprocessed.column = currentColumn + 1
      } else {
        ignoringWhitespace = false
        if mightExitSingleQuotedString {
          printLine("might exit single quoted string...")
          if char != '\'' {
            printLine("exiting single quoted string.")
            checkIndents = true
            inSingleQuotedString = false
            mightExitSingleQuotedString = false
            pushUnprocessed()
          }
        }
        if inDoubleQuotedString {
          unprocessed += char
          if acceptNext {
            acceptNext = false
          } else if char == '"' {
            inDoubleQuotedString = false
            checkIndents = true
            pushUnprocessed()
          } else if char == '\\' {
            acceptNext = true
          }
        } else if inSingleQuotedString {
          unprocessed += char
          if mightExitSingleQuotedString
            mightExitSingleQuotedString = false
          else if char == '\''
            mightExitSingleQuotedString = true
        } else if checkingForArray {
          checkingForArray = false
          if char == ' ' {
            unprocessed.value = unprocessed.value.substring(length: unprocessed.value.length - 1)
            pushUnprocessed()
            unprocessed.column = currentColumn + 1
            if (!lastTok || (*lastTok).type != TokenType.Indent) && (indents.top != currentColumn - 1) {
              indents.push(currentColumn - 1)
              let str: String
              for i: Size in 0..indents.top {
                str += ' '
              }
              pushToken(new Token(TokenType.Indent, currentLine, currentColumn - 1, str))
            }
            pushToken(new Token(TokenType.SequenceIndicator, currentLine, currentColumn - 1))
            ignoringWhitespace = true
          } else {
            unprocessed += char
          }
        } else if checkingForSeparator {
          checkingForSeparator = false
          if char == ' ' || char == '\n' {
            unprocessed.value = unprocessed.value.substring(length: unprocessed.value.length - 1)
            printLine("unprocessed = ", unprocessed.value, "; unprocessed.column = ", unprocessed.column, "; indents.top = ", indents.top)
            if indents.length == 0 || (unprocessed.column > indents.top && unprocessed.value.length > 0) {
              indents.push(unprocessed.column)
              let str: String
              for i: Size in 0..indents.top {
                str += ' '
              }
              pushToken(new Token(TokenType.Indent, currentLine, unprocessed.column, str))
            }
            pushUnprocessed()
            if char == '\n'
              unprocessed = new Token("", currentLine + 1, 0)
            else
              unprocessed.column = currentColumn + 1
            pushToken(new Token(TokenType.KeyValueSeparator, currentLine, currentColumn - 1))
            ignoringWhitespace = true
          } else {
            unprocessed += char
          }
        } else if char == '-' {
          checkingForArray = true
          unprocessed += char
        } else if char == ':' {
          checkingForSeparator = true
          unprocessed += char
        } else if char == '"' {
          inDoubleQuotedString = true
          checkIndents = false
          pushUnprocessed()
          unprocessed += char
        } else if char == '\'' {
          inSingleQuotedString = true
          checkIndents = false
          pushUnprocessed()
          unprocessed += char
        } else if char == '\n' {
          pushUnprocessed()
          unprocessed.line = currentLine + 1
          unprocessed.column = 0
        } else if char == '{' {
          pushUnprocessed()
          pushToken(new Token(TokenType.MappingStartIndicator, currentLine, currentColumn))
        } else if char == '}' {
          pushUnprocessed()
          pushToken(new Token(TokenType.MappingEndIndicator, currentLine, currentColumn))
        } else if char == '[' {
          pushUnprocessed()
          pushToken(new Token(TokenType.SequenceStartIndicator, currentLine, currentColumn))
        } else if char == ']' {
          pushUnprocessed()
          pushToken(new Token(TokenType.SequenceEndIndicator, currentLine, currentColumn))
        } else if char == ',' {
          pushUnprocessed()
          pushToken(new Token(TokenType.ItemSeparator, currentLine, currentColumn))
        } else if char == '?' {
          pushUnprocessed()
          pushToken(new Token(TokenType.ComplexKeyIndicator, currentLine, currentColumn))
          ignoringWhitespace = true
        } else {
          unprocessed += char
        }
      }

      if char == '\n' {
        currentLine += 1
        currentColumn = 0
      } else {
        currentColumn += 1
      }
    }
  }

  public function parse(): void {
    let levels: Stack<Level>

    levels.push(new Level(Rule.Expression))

    levels.top.isRoot = true
    levels.top.state = 2

    let it = this.tokens.items
    let lastNode: YAML.NodeBox = nullptr
    let tok: (ref Token)? = it.next()

    while tok {
      let token = *tok

      if token.type == TokenType.Indent
        printLine("indent token of ", token.value.length, " spaces found at ", token.line + 1, ':', token.column + 1)
      else if token.type == TokenType.Outdent
        printLine("outdent token of ", token.value.length, " spaces found at ", token.line + 1, ':', token.column + 1)
      else if token.type == TokenType.SequenceIndicator
        printLine("sequence indicator found at ", token.line + 1, ':', token.column + 1)
      else if token.type == TokenType.KeyValueSeparator
        printLine("key value separator found at ", token.line + 1, ':', token.column + 1)
      else if token.type == TokenType.Scalar
        printLine("scalar token found at ", token.line + 1, ':', token.column + 1, " with content: \"", escape(token.value), '"')
      else if token.type == TokenType.MappingStartIndicator
        printLine("mapping start indicator found at ", token.line + 1, ':', token.column + 1)
      else if token.type == TokenType.MappingEndIndicator
        printLine("mapping end indicator found at ", token.line + 1, ':', token.column + 1)
      else if token.type == TokenType.SequenceStartIndicator
        printLine("sequence start indicator found at ", token.line + 1, ':', token.column + 1)
      else if token.type == TokenType.SequenceEndIndicator
        printLine("sequence end indicator found at ", token.line + 1, ':', token.column + 1)
      else if token.type == TokenType.ItemSeparator
        printLine("item separator found at ", token.line + 1, ':', token.column + 1)
      else if token.type == TokenType.EOF
        printLine("EOF found")
      else if token.type == TokenType.ComplexKeyIndicator
        printLine("complex key indicator found at ", token.line + 1, ':', token.column + 1)
      else
        printLine("token found at ", token.line + 1, ':', token.column + 1, " with content: \"", escape(token.value), '"')

      if levels.length == 0 {
        if token.type != TokenType.EOF
          throw new UnexpectedExit
        else
          break
      }

      let level: ref Level = levels.top
      level.iteration += 1

      let levelCount = levels.length

      let goToNextToken = true

      if level.state == 0 {
        if token.type == TokenType.Indent {
          level.rootIndent = token.value.length
          level.state = 2
        } else {
          level.rootIndent = 0
          level.state = 1
          goToNextToken = false
        }
      } else {
        if level.handedOff {
          level.handedOff = false
          let tmp: String
          if lastNode
            tmp = (lastNode as ref YAML.Node).toString()
          else
            tmp = new String("<unknown>")
          printLine("coming back from handed off rule; result is ", tmp)
          if level.rule == Rule.Mapping || level.rule == Rule.FlowMapping {
            if level.gettingKey {
              level.gettingKey = false
              level.cache.push(lastNode)
            } else {
              (level.node as ref YAML.Mapping)[level.cache.pop()] = lastNode
            }
          } else if level.rule == Rule.Sequence || level.rule == Rule.FlowSequence {
            (level.node as ref YAML.Sequence).push(lastNode)
          }
          lastNode = nullptr
          if level.rule == Rule.FlowMapping || level.rule == Rule.FlowSequence
            level.needsSeparator = true
        }
        if token.type == TokenType.ItemSeparator && level.rule != Rule.FlowMapping && level.rule != Rule.FlowSequence {
          lastNode = level.node
          levels.pop()
          goToNextToken = false
        } else if token.type == TokenType.Outdent {
          if level.rule != Rule.FlowMapping && level.rule != Rule.FlowSequence {
            if level.state == 1 || token.value.length < level.rootIndent {
              lastNode = level.node
              levels.pop()
              goToNextToken = false
            } else {
              level.currentAddedSpaces = token.value.length
            }
          }
        } else if token.type == TokenType.Indent {
          if level.state == 1 {
            level.rootIndent = token.value.length
            level.state = 2
          }
          if level.rule != Rule.FlowMapping && level.rule != Rule.FlowSequence
            level.currentAddedSpaces = token.value.length
        } else if level.needsSeparator {
          printLine("needing separator... found ", token.type)
          if token.type == TokenType.ItemSeparator {
            level.needsSeparator = false
            if level.rule == Rule.FlowSequence
              level.checkForEnd = true
          } else if (
            (token.type == TokenType.MappingEndIndicator && level.rule == Rule.FlowMapping) ||
            (token.type == TokenType.SequenceEndIndicator && level.rule == Rule.FlowSequence)
          ) {
            lastNode = level.node
            levels.pop()
          } else {
            throw new UnexpectedToken
          }
        } else if (
          (token.type == TokenType.MappingEndIndicator && level.rule == Rule.FlowMapping) ||
          (token.type == TokenType.SequenceEndIndicator && level.rule == Rule.FlowSequence)
        ) {
          lastNode = level.node
          levels.pop()
        } else if level.checkForEnd {
          level.checkForEnd = false
          level.handedOff = true
          levels.push(new Level(Rule.Expression))
          goToNextToken = false
        } else if token.type == TokenType.Scalar || token.type == TokenType.Any {
          if level.rule == Rule.Mapping || level.rule == Rule.FlowMapping {
            printLine("caching a token: ", token.value)
            level.cache.push(new* YAML.String(token))
          } else {
            let first = false
            if level.node {
              printLine("found scalar and node; current added spaces = ", level.currentAddedSpaces)
              if level.currentAddedSpaces == 0 {
                lastNode = level.node
                levels.pop()
                goToNextToken = false
              }
            } else {
              first = true
              level.rule = Rule.Scalar
              level.node = new* YAML.String
            }
            if goToNextToken {
              let str = level.node as ref YAML.String
              if !first
                str += '\n'
              if level.currentAddedSpaces > level.rootIndent {
                for i: Size in 0..(level.currentAddedSpaces - level.rootIndent) {
                  str += ' '
                }
              }
              str += token.value
            }
          }
        } else if token.type == TokenType.KeyValueSeparator {
          if level.rule != Rule.Mapping && level.rule != Rule.FlowMapping {
            if level.isComplexKey {
              lastNode = level.node
              levels.pop()
              goToNextToken = false
            } else {
              printLine("creating a brand new mapping from ", (level.node as ref YAML.Node).toString())
              let reassignRoot = this.root == level.node
              level.cache.push(level.node as ref YAML.String)
              level.node = new* YAML.Mapping
              if reassignRoot
                this.root = level.node
              printLine("level.rule was ", level.rule)
              level.rule = Rule.Mapping
              printLine("level.rule is now ", level.rule)
            }
          }
          if goToNextToken {
            printLine("handing off...")
            level.handedOff = true
            levels.push(new Level(Rule.Expression))
            if level.rule == Rule.FlowMapping
              levels.top.noBlock = true
          }
        } else if token.type == TokenType.SequenceIndicator {
          if level.noBlock {
            throw new InvalidBlockSequenceLocation
          }
          if level.rule == Rule.Expression {
            let reassignRoot = this.root == level.node
            level.node = new* YAML.Sequence
            if reassignRoot
              this.root = level.node
            level.rule = Rule.Sequence
          } else if level.rule != Rule.Sequence {
            goToNextToken = false
            lastNode = level.node
            levels.pop()
          }
          if goToNextToken {
            level.handedOff = true
            levels.push(new Level(Rule.Expression))
          }
        } else if token.type == TokenType.EOF {
          if levels.length != 1
            goToNextToken = false
          lastNode = level.node
          levels.pop()
        } else if token.type == TokenType.MappingStartIndicator {
          level.rule = Rule.FlowMapping
          level.node = new* YAML.Mapping
        } else if token.type == TokenType.SequenceStartIndicator {
          level.rule = Rule.FlowSequence
          level.node = new* YAML.Sequence
          level.checkForEnd = true
        } else if token.type == TokenType.ComplexKeyIndicator {
          if level.rule == Rule.Expression {
            let reassignRoot = this.root == level.node
            level.node = new* YAML.Mapping
            if reassignRoot
              this.root = level.node
            level.rule = Rule.Mapping
          } else if level.rule != Rule.Mapping && level.rule != Rule.FlowMapping {
            lastNode = level.node
            levels.pop()
            goToNextToken = false
          }
          if goToNextToken {
            printLine("handing off to a complex key...")
            level.handedOff = true
            level.gettingKey = true
            levels.push(new Level(Rule.Expression))
            levels.top.isComplexKey = true
          }
        }
      }

      if goToNextToken
        tok = it.next()

      if levelCount == levels.length && !this.root && level.node
        this.root = level.node
    }
  }
}
